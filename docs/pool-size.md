## 각각의 최적값 공식

### 1. **커넥션 풀 (HikariCP)**
> 최적값 = CPU 코어 수 × 2 + 디스크 수
- **I/O 대기 시간** 고려
- DB 쿼리는 디스크 I/O 대기가 많음

### 2. **톰캣 스레드 풀 (Web Server)**
> 최적값 = 200 ~ 250 (기본값)
- 동시 HTTP 요청 수 기준
- CPU 코어와 무관
- 예: 동시 접속 1000명 → 200개면 충분 (Keep-Alive)

### 3. **전용 스레드풀 (예: @Async)**
> 최적값 = CPU 바운드 → CPU 코어 수
> I/O 바운드 → CPU 코어 수 × 2~4
- CPU 연산: 코어 수만큼
- I/O 작업: 더 많이

---

## 왜 다른가?

| 풀 종류 | 병목 지점 | 최적화 기준 |
|---------|-----------|-------------|
| **커넥션 풀** | DB I/O 대기 | CPU + 디스크 |
| **톰캣 스레드** | 네트워크 I/O | 동시 요청 수 |
| **비즈니스 스레드** | CPU 또는 I/O | 작업 특성 |

---

## 관계도
```
클라이언트 요청 (1000명)
    ↓
톰캣 스레드 (200개) ← 동시 처리 가능 수
    ↓
비즈니스 로직
    ↓
커넥션 풀 (10개) ← DB 동시 접속 수
    ↓
PostgreSQL
```

---

## 실무 예시
### 8코어 서버 기준:

- 톰캣 스레드: 200개 (동시 요청 처리)
- 커넥션 풀: 20개 (8×2+4)
- Async 스레드: 16개 (I/O 작업용)

왜 톰캣이 더 많은가?
→ 대부분 시간은 대기 중 (I/O 블로킹)
→ CPU는 안 쓰고 대기만 함
→ 스레드 많아도 괜찮음